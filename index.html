<!DOCTYPE html>
<html>
  <head>
    <title>WebRTC Test</title>
    <link rel="icon" href="data:," />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/7.0.5/signalr.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
      }
      .video-container {
        display: flex;
        gap: 20px;
        margin-top: 20px;
      }
      video {
        width: 300px;
        height: 200px;
        border: 2px solid #ddd;
        border-radius: 8px;
        background: #000;
      }
      button {
        background: #007bff;
        color: white;
        border: none;
        padding: 10px 15px;
        margin: 5px;
        border-radius: 5px;
        cursor: pointer;
      }
      button:hover {
        background: #0056b3;
      }
      button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      .status {
        margin: 10px 0;
        padding: 10px;
        border-radius: 5px;
      }
      .status.connected {
        background: #d4edda;
        color: #155724;
      }
      .status.error {
        background: #f8d7da;
        color: #721c24;
      }
      input {
        padding: 8px;
        margin: 5px;
        border: 1px solid #ddd;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <h2>WebRTC Test</h2>

    <div id="info"></div>
    <div id="status" class="status"></div>

    <div>
      <label
        >Remote ID:
        <input id="remoteId" value="user2" placeholder="Nh·∫≠p ID ng∆∞·ªùi nh·∫≠n"
      /></label>
    </div>

    <div>
      <button id="videoCallBtn" onclick="startCall('video')">
        üìπ G·ªçi video
      </button>
      <button id="audioCallBtn" onclick="startCall('audio')">
        üéß G·ªçi audio
      </button>
      <button id="hangupBtn" onclick="hangup()" disabled>üìû C√∫p m√°y</button>
    </div>

    <div class="video-container">
      <div>
        <h4>Video c·ªßa b·∫°n</h4>
        <video id="localVideo" autoplay muted playsinline></video>
      </div>
      <div>
        <h4>Video ƒë·ªëi ph∆∞∆°ng</h4>
        <video id="remoteVideo" autoplay playsinline></video>
      </div>
    </div>

    <script>
      let userId = prompt("Nh·∫≠p user ID c·ªßa b·∫°n:", "user1");
      if (!userId) {
        alert("C·∫ßn ph·∫£i c√≥ User ID ƒë·ªÉ ti·∫øp t·ª•c!");
        location.reload();
      }

      document.getElementById(
        "info"
      ).innerText = `B·∫°n ƒëang ƒëƒÉng nh·∫≠p v·ªõi ID: ${userId}`;

      const remoteIdInput = document.getElementById("remoteId");
      const statusDiv = document.getElementById("status");
      const videoCallBtn = document.getElementById("videoCallBtn");
      const audioCallBtn = document.getElementById("audioCallBtn");
      const hangupBtn = document.getElementById("hangupBtn");

      let peer,
        localStream,
        isInCall = false;

      // C·∫≠p nh·∫≠t tr·∫°ng th√°i UI
      function updateStatus(message, isError = false) {
        statusDiv.textContent = message;
        statusDiv.className = `status ${isError ? "error" : "connected"}`;
      }

      function updateButtonStates() {
        videoCallBtn.disabled = isInCall;
        audioCallBtn.disabled = isInCall;
        hangupBtn.disabled = !isInCall;
      }

      const notifyHub = new signalR.HubConnectionBuilder()
        .withUrl("https://api.ltc365.com/hub/notify?userId=" + userId)
        .build();

      const webrtcHub = new signalR.HubConnectionBuilder()
        .withUrl("https://api.ltc365.com/hub/webrtc?userId=" + userId)
        .build();

      // X·ª≠ l√Ω nh·∫≠n cu·ªôc g·ªçi
      notifyHub.on("ReceiveCall", async (fromUserId, type) => {
        if (isInCall) {
          updateStatus("ƒêang trong cu·ªôc g·ªçi kh√°c, kh√¥ng th·ªÉ nh·∫≠n!", true);
          return;
        }

        const accept = confirm(
          `üìû Cu·ªôc g·ªçi ${type} t·ª´ ${fromUserId}. B·∫°n c√≥ mu·ªën nh·∫≠n kh√¥ng?`
        );
        if (!accept) return;

        try {
          const constraints =
            type === "video"
              ? { video: true, audio: true }
              : { video: false, audio: true };

          localStream = await navigator.mediaDevices.getUserMedia(constraints);
          document.getElementById("localVideo").srcObject = localStream;

          peer = createPeer(fromUserId);
          localStream
            .getTracks()
            .forEach((track) => peer.addTrack(track, localStream));

          isInCall = true;
          updateButtonStates();
          updateStatus(`ƒêang trong cu·ªôc g·ªçi ${type} v·ªõi ${fromUserId}...`);
        } catch (error) {
          console.error("L·ªói khi nh·∫≠n cu·ªôc g·ªçi:", error);
          updateStatus("L·ªói khi truy c·∫≠p camera/microphone!", true);
        }
      });

      webrtcHub.on("ReceiveOffer", async (fromId, offer) => {
        try {
          console.log("Received offer from:", fromId, "Data:", offer);

          // Ki·ªÉm tra d·ªØ li·ªáu offer h·ª£p l·ªá
          if (!offer || offer === "null" || offer === "undefined") {
            console.error("Invalid offer data:", offer);
            updateStatus("Nh·∫≠n ƒë∆∞·ª£c offer kh√¥ng h·ª£p l·ªá!", true);
            return;
          }

          if (!peer) {
            peer = createPeer(fromId);
          }

          // Parse v√† validate offer
          let parsedOffer;
          try {
            parsedOffer = JSON.parse(offer);
          } catch (parseError) {
            console.error("Failed to parse offer JSON:", parseError);
            updateStatus("L·ªói parse offer JSON!", true);
            return;
          }

          // Ki·ªÉm tra offer c√≥ ƒë√∫ng format kh√¥ng
          if (!parsedOffer || !parsedOffer.type || !parsedOffer.sdp) {
            console.error("Invalid offer format:", parsedOffer);
            updateStatus("Format offer kh√¥ng h·ª£p l·ªá!", true);
            return;
          }

          await peer.setRemoteDescription(
            new RTCSessionDescription(parsedOffer)
          );

          const answer = await peer.createAnswer();
          await peer.setLocalDescription(answer);

          await axios.post("https://api.ltc365.com/api/WebRTC/send-answer", {
            toUserId: fromId,
            fromUserId: userId,
            data: JSON.stringify(answer),
          });

          updateStatus("ƒê√£ g·ª≠i answer th√†nh c√¥ng");
        } catch (error) {
          console.error("L·ªói khi x·ª≠ l√Ω offer:", error);
          updateStatus("L·ªói khi x·ª≠ l√Ω offer!", true);
        }
      });

      webrtcHub.on("ReceiveAnswer", async (fromId, answer) => {
        try {
          console.log("Received answer from:", fromId, "Data:", answer);

          // Ki·ªÉm tra d·ªØ li·ªáu answer h·ª£p l·ªá
          if (!answer || answer === "null" || answer === "undefined") {
            console.error("Invalid answer data:", answer);
            updateStatus("Nh·∫≠n ƒë∆∞·ª£c answer kh√¥ng h·ª£p l·ªá!", true);
            return;
          }

          if (!peer) {
            console.error("No peer connection available");
            updateStatus("Kh√¥ng c√≥ k·∫øt n·ªëi peer!", true);
            return;
          }

          // Parse v√† validate answer
          let parsedAnswer;
          try {
            parsedAnswer = JSON.parse(answer);
          } catch (parseError) {
            console.error("Failed to parse answer JSON:", parseError);
            updateStatus("L·ªói parse answer JSON!", true);
            return;
          }

          // Ki·ªÉm tra answer c√≥ ƒë√∫ng format kh√¥ng
          if (!parsedAnswer || !parsedAnswer.type || !parsedAnswer.sdp) {
            console.error("Invalid answer format:", parsedAnswer);
            updateStatus("Format answer kh√¥ng h·ª£p l·ªá!", true);
            return;
          }

          await peer.setRemoteDescription(
            new RTCSessionDescription(parsedAnswer)
          );
          updateStatus("K·∫øt n·ªëi th√†nh c√¥ng!");
        } catch (error) {
          console.error("L·ªói khi x·ª≠ l√Ω answer:", error);
          updateStatus("L·ªói khi x·ª≠ l√Ω answer!", true);
        }
      });

      webrtcHub.on("ReceiveIceCandidate", async (fromId, candidate) => {
        try {
          console.log(
            "Received ICE candidate from:",
            fromId,
            "Data:",
            candidate
          );

          // Ki·ªÉm tra d·ªØ li·ªáu candidate h·ª£p l·ªá
          if (!candidate || candidate === "null" || candidate === "undefined") {
            console.error("Invalid candidate data:", candidate);
            return;
          }

          if (!peer) {
            console.error("No peer connection available for ICE candidate");
            return;
          }

          if (!peer.remoteDescription) {
            console.warn(
              "Remote description not set yet, skipping ICE candidate"
            );
            return;
          }

          // Parse v√† validate candidate
          let parsedCandidate;
          try {
            parsedCandidate = JSON.parse(candidate);
          } catch (parseError) {
            console.error("Failed to parse candidate JSON:", parseError);
            return;
          }

          // Ki·ªÉm tra candidate c√≥ ƒë√∫ng format kh√¥ng
          if (
            !parsedCandidate ||
            typeof parsedCandidate.candidate === "undefined"
          ) {
            console.error("Invalid candidate format:", parsedCandidate);
            return;
          }

          await peer.addIceCandidate(new RTCIceCandidate(parsedCandidate));
        } catch (error) {
          console.error("L·ªói khi th√™m ICE candidate:", error);
        }
      });

      async function startCall(type) {
        const toUser = remoteIdInput.value.trim();
        if (!toUser) {
          alert("Vui l√≤ng nh·∫≠p Remote ID!");
          return;
        }

        if (toUser === userId) {
          alert("Kh√¥ng th·ªÉ g·ªçi cho ch√≠nh m√¨nh!");
          return;
        }

        if (isInCall) {
          alert("ƒêang trong cu·ªôc g·ªçi kh√°c!");
          return;
        }

        try {
          // G·ª≠i th√¥ng b√°o cu·ªôc g·ªçi
          await axios.post("https://api.ltc365.com/api/Notify/send-call", {
            idUsersRecive: toUser,
            idUserSend: userId,
            title: "Cu·ªôc g·ªçi ƒë·∫øn",
            message: `Cu·ªôc g·ªçi ${type} t·ª´ ${userId}`,
            type: type,
            sentAt: new Date().toISOString(),
          });

          const constraints =
            type === "video"
              ? { video: true, audio: true }
              : { video: false, audio: true };

          localStream = await navigator.mediaDevices.getUserMedia(constraints);
          document.getElementById("localVideo").srcObject = localStream;

          peer = createPeer(toUser);
          localStream
            .getTracks()
            .forEach((track) => peer.addTrack(track, localStream));

          const offer = await peer.createOffer();
          await peer.setLocalDescription(offer);
          console.log("Sending offer:", JSON.stringify(offer));
          const res = await axios.post(
            "https://api.ltc365.com/api/WebRTC/send-offer",
            {
              toUserId: toUser,
              fromUserId: userId,
              Data: JSON.stringify(offer),
            }
          );
          if (res.status !== 200 && res.status !== 204) {
            throw new Error("send-offer th·∫•t b·∫°i");
          }

          isInCall = true;
          updateButtonStates();
          updateStatus(`ƒêang g·ªçi ${type} cho ${toUser}...`);
        } catch (error) {
          console.error("L·ªói khi b·∫Øt ƒë·∫ßu cu·ªôc g·ªçi:", error);
          updateStatus("L·ªói khi b·∫Øt ƒë·∫ßu cu·ªôc g·ªçi!", true);

          // Cleanup n·∫øu c√≥ l·ªói
          if (localStream) {
            localStream.getTracks().forEach((track) => track.stop());
            localStream = null;
          }
          if (peer) {
            peer.close();
            peer = null;
          }
          isInCall = false;
          updateButtonStates();
        }
      }

      function hangup() {
        if (localStream) {
          localStream.getTracks().forEach((track) => track.stop());
          localStream = null;
        }

        if (peer) {
          peer.close();
          peer = null;
        }

        document.getElementById("localVideo").srcObject = null;
        document.getElementById("remoteVideo").srcObject = null;

        isInCall = false;
        updateButtonStates();
        updateStatus("ƒê√£ c√∫p m√°y");
      }

      function createPeer(toUserId) {
        const pc = new RTCPeerConnection({
          iceServers: [
            { urls: "stun:stun.l.google.com:19302" },
            { urls: "stun:stun1.l.google.com:19302" },
          ],
        });

        pc.onicecandidate = async (event) => {
          if (event.candidate) {
            try {
              await axios.post("https://api.ltc365.com/api/WebRTC/send-ice", {
                toUserId: toUserId,
                fromUserId: userId,
                data: JSON.stringify(event.candidate),
              });
            } catch (error) {
              console.error("L·ªói khi g·ª≠i ICE candidate:", error);
            }
          }
        };

        pc.ontrack = (event) => {
          document.getElementById("remoteVideo").srcObject = event.streams[0];
          updateStatus("ƒê√£ k·∫øt n·ªëi th√†nh c√¥ng!");
        };

        pc.onconnectionstatechange = () => {
          console.log("Connection state:", pc.connectionState);
          if (
            pc.connectionState === "failed" ||
            pc.connectionState === "disconnected"
          ) {
            updateStatus("K·∫øt n·ªëi b·ªã ng·∫Øt!", true);
          }
        };

        return pc;
      }

      async function start() {
        try {
          updateStatus("ƒêang k·∫øt n·ªëi...");

          await notifyHub.start();
          await webrtcHub.start();

          console.log("‚úÖ SignalR connected.");
          updateStatus("ƒê√£ k·∫øt n·ªëi th√†nh c√¥ng. S·∫µn s√†ng th·ª±c hi·ªán cu·ªôc g·ªçi!");
          updateButtonStates();
        } catch (err) {
          console.error("‚ùå SignalR connection error:", err);
          updateStatus("L·ªói k·∫øt n·ªëi SignalR!", true);
        }
      }

      // Cleanup khi ƒë√≥ng trang
      window.addEventListener("beforeunload", () => {
        hangup();
      });

      start();
    </script>
  </body>
</html>
